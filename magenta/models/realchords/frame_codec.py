# Copyright 2024 The Magenta Authors.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""Codec for transform between frame-based tokens to hooktheory Song."""

from typing import Any, Mapping, Optional, Sequence

from magenta.models.realchords import data
from magenta.models.realchords import event_codec
from magenta.models.realchords import sequence_utils
import numpy as np

_PAD_ID = 0
_EOS_ID = 1


def _trim_eos(tokens: Sequence[int]) -> np.ndarray:
  tokens = np.array(tokens, np.int32)
  if _EOS_ID in tokens:
    tokens = tokens[: np.argmax(tokens == _EOS_ID)]
  return tokens


def _frame_song_tokens_to_features(
    tokens: Sequence[int],
    codec: event_codec.Codec,
    downsample_rate: int,
    model_part: str = 'chord',
    order: str = 'causal',
) -> Mapping[str, Any]:
  """Tokens to frame-based song tokens to integer tokens."""
  song = data.parse_song(tokens)
  chord_events = data.chords_to_frames(song.chords, downsample_rate)
  note_events = data.notes_to_frames(song.notes, downsample_rate)
  if order == 'causal':
    target_events = data.interleave_chord_note_events(
        chord_events, note_events, model_part=model_part
    )
    return {
        'targets': [codec.encode_event(e) for e in target_events],
    }
  elif order == 'non_causal':
    chord_events, note_events = data.event_list_to_same_length(
        chord_events, note_events
    )
    if model_part == 'chord':
      return {
          'inputs': [codec.encode_event(e) for e in note_events],
          'targets': [codec.encode_event(e) for e in chord_events],
      }
    elif model_part == 'note':
      return {
          'inputs': [codec.encode_event(e) for e in chord_events],
          'targets': [codec.encode_event(e) for e in note_events],
      }
    else:
      raise ValueError(f'Unknown model_part: {model_part}')
  else:
    raise ValueError(f'Unknown order: {order}')


def get_frame_codec() -> event_codec.Codec:
  """Get event-based melody-to-chords codec."""
  event_ranges = [
      # We don't have chord_on-rest token
      event_codec.EventRange(
          'chord_on', 0, data.MAX_CHORD_IDX - data.MIN_CHORD_IDX
      ),
      # For chord (hold) token, we add 1 to vocab for the chord-rest
      event_codec.EventRange(
          'chord', 0, data.MAX_CHORD_IDX - data.MIN_CHORD_IDX + 1
      ),
      # Similar for note
      event_codec.EventRange(
          'note_on', 0, data.MAX_NOTE_IDX - data.MIN_NOTE_IDX
      ),
      event_codec.EventRange(
          'note', 0, data.MAX_NOTE_IDX - data.MIN_NOTE_IDX + 1
      ),
  ]
  return event_codec.Codec(event_ranges=event_ranges)


def postprocess_frame_example(
    codec: event_codec.Codec,
    tokens: Sequence[int],
    example: Optional[Mapping[str, Any]],
    is_target: bool = False,
    model_part: str = 'chord',
    order: str = 'causal',
    upsample_rate: int = data.FRAME_DOWNSAMPLE_RATE,
) -> Mapping[str, Any]:
  """Postprocess frame-based causal or non-causal example."""
  del is_target
  original_tokens = tokens
  tokens = _trim_eos(tokens)

  if order == 'causal':
    tokens = sequence_utils.pad_for_multiple_1d(tokens, 2, _PAD_ID)
    # If the tokens comes from online generation model, we need to mask
    # the extra tokens generated by model where condition token is PAD.
    if model_part == 'chord':
      chord_tokens = np.array(tokens[::2])
      note_tokens = np.array(tokens[1::2])
      chord_tokens[note_tokens == _PAD_ID] = _PAD_ID
    elif model_part == 'note':
      note_tokens = np.array(tokens[::2])
      chord_tokens = np.array(tokens[1::2])
      note_tokens[chord_tokens == _PAD_ID] = _PAD_ID
    else:
      raise ValueError(f'Unknown model_part: {model_part}')

  elif order == 'non_causal':
    if model_part == 'chord':
      chord_tokens = _trim_eos(tokens)
      note_tokens = _trim_eos(example['inputs'])
    elif model_part == 'note':
      note_tokens = _trim_eos(tokens)
      chord_tokens = _trim_eos(example['inputs'])
    else:
      raise ValueError(f'Unknown model_part: {model_part}')
  else:
    raise ValueError(f'Unknown order: {order}')

  # Remove padding in case tokens has padding:
  chord_tokens = chord_tokens[chord_tokens != _PAD_ID]
  note_tokens = note_tokens[note_tokens != _PAD_ID]

  try:
    chords = data.frames_to_chords(chord_tokens, codec, upsample_rate)
    notes = data.frames_to_notes(note_tokens, codec, upsample_rate)
  # The data should interleave tokens of chords and notes.
  # If wrong tokens are generated, (i.e. chord token on position of notes)
  # we just return empty song.
  except ValueError:
    chords = []
    notes = []
  return {
      'song': data.Song(chords=chords, notes=notes),
      'tokens': np.array(original_tokens),
  }

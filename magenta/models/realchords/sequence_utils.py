# Copyright 2024 The Magenta Authors.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""Utilities functions for permuting sequence order."""

from typing import Tuple

import jax.numpy as jnp
import numpy as np
import tensorflow as tf

Array = np.ndarray | jnp.ndarray


def pad_to_length_1d(array: Array, length: int, pad_value: int = 0) -> Array:
  """Chunk or pad audio into desired length."""
  if len(array) < length:
    array = np.pad(
        array, (0, length - len(array)), 'constant', constant_values=pad_value
    )
  else:
    array = array[:length]
  return array


def pad_for_multiple_1d(data: Array, multiple: int, pad_value: int) -> Array:
  """Pad the 1-d data to make the length as the multiple of "multiple"."""
  if len(data) % multiple == 0:
    return data
  else:
    len_to_pad = multiple - (len(data) % multiple)
    data = np.pad(
        data,
        [0, len_to_pad],
        constant_values=pad_value,
    )
    return data


def pad_for_multiple_2d(data: Array, multiple: int, pad_value: int) -> Array:
  """Pad the 2-d data to make the length as the multiple of "multiple".

  The second dimension (axis=1) is the length dimension to pad.

  Args:
    data: The 2-d array to be padded.
    multiple: The number to pad the length dimension to make it as the multiple
      of "multiple".
    pad_value: The value to pad.

  Returns:
    A 2-d array after padding.
  """
  if data.shape[1] % multiple == 0:
    return data
  else:
    len_to_pad = multiple - (data.shape[1] % multiple)
    data = jnp.pad(
        data,
        [[0, 0], [0, len_to_pad]],
        constant_values=pad_value,
    )
    return data


def pad_for_multiple_nd(data: Array, multiple: int, pad_value: int) -> Array:
  """Pad the N-d data to make the length as the multiple of "multiple".

  The second dimension (axis=1) is the length dimension to pad.

  Args:
    data: The N-d array to be padded.
    multiple: The number to pad the length dimension to make it as the multiple
      of "multiple".
    pad_value: The value to pad.

  Returns:
    A N-d array after padding.
  """
  batch_size = data.shape[0]
  length = data.shape[1]
  residual_shape = data.shape[2:]

  tensor_to_pad = jnp.full(
      [batch_size, length % multiple, *residual_shape], pad_value
  )
  tensor = jnp.concatenate([data, tensor_to_pad], axis=1)
  return tensor


def causal_to_non_causal_tf(
    tensor: tf.Tensor, num_instruments: int = 2
) -> tf.Tensor:
  """Permute to non-causal sequence with tf Tensor as input.

  Currently only works for two part data.
  E.g.: SASASASA -> AAAASSSS. By default the first part is generated by model.

  Args:
    tensor: The tensor as input of shape [B, T]
    num_instruments: number of instrument in this dataset. Now it can be only 2.

  Returns:
    A tensor with data after permutation.
  """
  if num_instruments != 2:
    raise ValueError('num_instruments must be equal to 2')
  batch_size = tensor.shape[0]
  chorales = tf.reshape(tensor, (batch_size, -1, num_instruments))
  output = tf.concat([chorales[:, :, 1], chorales[:, :, 0]], axis=1)
  return output


def causal_to_non_causal_np(tensor: Array, num_instruments: int = 2) -> Array:
  """Permute to non-causal sequence with numpy / jax array as input.

  Currently only works for two part data.
  E.g.: SASASASA -> AAAASSSS. This function assumes the first part is generated
    by model.

  Args:
    tensor: The tensor as input of shape [B, T, *]
    num_instruments: number of instrument in this dataset. Now it can be only 2.

  Returns:
    A tensor with data after permutation.
  """
  if num_instruments != 2:
    raise ValueError('num_instruments must be equal to 2')
  batch_size = tensor.shape[0]
  residual_shape = tensor.shape[2:]
  chorales = jnp.reshape(
      tensor, (batch_size, -1, num_instruments, *residual_shape)
  )
  output = jnp.concatenate(
      [chorales[:, :, 1, ...], chorales[:, :, 0, ...]], axis=1
  )
  return output


def non_causal_to_causal_np(tensor: Array, pad_value: int = 0) -> Array:
  """Convert non-causal numpy / jax array sequence to normal sequence.

  For example: AAAASSSS -> SASASASA. This function also assumes two instruments
    and the last half of the sequence is generated by model.

  Args:
    tensor: The non-causal array as input in shape [B, T].
    pad_value: The value to pad if the length of the array is not the multiple
      of 2.

  Returns:
    An array with permuted order.
  """
  # Pad to make sure tensor is multiple of 2
  tensor = pad_for_multiple_nd(tensor, 2, pad_value)
  batch_size = tensor.shape[0]
  length = tensor.shape[1]
  residual_shape = tensor.shape[2:]
  half_length = length // 2
  output = jnp.concatenate(
      [tensor[:, half_length:], tensor[:, :half_length]], axis=1
  )
  output = jnp.reshape(output, [batch_size, 2, -1, *residual_shape])
  output = jnp.swapaxes(output, 1, 2)
  output = jnp.reshape(output, [batch_size, -1, *residual_shape])

  return output


def causal_to_enc_dec_np(
    tensor: Array, pad_value: int = 0
) -> Tuple[Array, Array]:
  """Convert causal sequence to input for encoder-decoder model.

  For example: SASASASA -> {'inputs': AAAA, 'targets': SSSS}.
  This function assumes two instruments and the last half of the sequence is
    generated by model.

  Args:
    tensor: The causal array as input in shape [B, T].
    pad_value: The value to pad if the length of the array is not the multiple
      of 2.

  Returns:
    A tuple of two arrays, inputs and targets.
  """
  # Pad to make sure tensor is multiple of 2
  tensor = pad_for_multiple_nd(tensor, 2, pad_value)
  targets = tensor[:, ::2]
  inputs = tensor[:, 1::2]
  return inputs, targets


def enc_dec_np_to_causal_np(
    inputs: Array,
    targets: Array,
) -> Array:
  """Convert encoder-decoder sequence to input for causal model.

  Assume inputs and targets has the same shape.

  Args:
    inputs: The input array to encoder-decoder model in shape [B, T].
    targets: The target array to encoder-decoder model in shape [B, T].

  Returns:
    An array in shape [B, 2*T]
  """
  assert inputs.shape == targets.shape
  batch_size = inputs.shape[0]
  length = inputs.shape[1]
  residual_shape = inputs.shape[2:]
  output = jnp.zeros([batch_size, length * 2, *residual_shape])
  output[:, ::2] = targets
  output[:, 1::2] = inputs
  return output


def add_eos(inputs: Array, eos_id: int = 1, pad_id: int = 0) -> Array:
  """Replace the first PAD token with EOS token.

  If there is no PAD token in EOS, then will replace inputs as is.
  Assume the shape of the input is [B,T].

  Args:
    inputs: The input array to add EOS.
    eos_id: The id of EOS token.
    pad_id: The id of PAD token.

  Returns:
    An array with EOS token.
  """
  inputs = jnp.array(inputs)
  assert inputs.ndim == 2
  pad_idx = inputs.argmin(axis=1)
  has_pad = (inputs == pad_id).any(axis=1)

  eos_to_add = jnp.zeros_like(inputs)
  eos_to_add = eos_to_add.at[jnp.arange(inputs.shape[0]), pad_idx].set(eos_id)
  eos_to_add *= has_pad.astype(jnp.int32)[:, None]
  inputs += eos_to_add
  return inputs


def chunk_sequence_sliding_window(
    sequences: Array, window_length: int, overlap_rate: float = 0.5
) -> Array:
  """Apply overlaping sliding window to chunk a sequence in [B,T]."""
  assert sequences.ndim == 2
  _, length = sequences.shape
  step_size = int(window_length * (1 - overlap_rate))

  # Calculate number of windows needed
  num_windows = (length - window_length) // step_size + 1
  assert num_windows > 0

  # Get the start indices
  start_indices = jnp.arange(0, length - window_length + 1, step_size)
  start_indices = start_indices[:num_windows]  # make sure not exceed seq length

  # Generate the indices of elements in each window
  indices = start_indices[:, None] + jnp.arange(window_length)

  # Index the sequence with indices to create each windows
  windows = sequences[:, None, :]
  chunked_sequence = windows[:, :, indices]
  chunked_sequence = chunked_sequence.reshape(-1, window_length)
  return chunked_sequence
